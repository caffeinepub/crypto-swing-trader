{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Enhance API reliability with advanced error recovery and caching",
  "requirements": [
    {
      "id": "REQ-55",
      "summary": "Implement staggered request sequencing in useCryptoPrices hook to reduce initial load API pressure by splitting 30 coin requests into 2-3 sequential batches with 100-200ms delays",
      "acceptanceCriteria": [
        "Initial dashboard load splits API requests into sequential batches",
        "Each batch has 100-200ms delay before next batch starts",
        "Rate limit errors on first load are significantly reduced"
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useCryptoPrices.ts",
          "operation": "modify",
          "description": "Add staggered batch request logic that splits the 30 cryptocurrency requests into 2-3 sequential batches with 100-200ms delays between batches. Track initial load state to apply staggered sequencing only on first dashboard load. Maintain existing 45-second auto-refresh interval and retry logic."
        }
      ]
    },
    {
      "id": "REQ-56",
      "summary": "Add client-side response caching to coingecko.ts service using Map-based cache with 30-45 second TTL to prevent redundant API calls during component remounts",
      "acceptanceCriteria": [
        "Successful CoinGecko responses are cached for 30-45 seconds",
        "Cached data is returned immediately without making new API calls",
        "Cache respects existing 45-second auto-refresh interval",
        "Cache is properly invalidated when stale"
      ],
      "file_operations": [
        {
          "path": "frontend/src/services/coingecko.ts",
          "operation": "modify",
          "description": "Implement Map-based response cache with timestamp tracking for both fetchTopCryptos and fetchOHLC functions. Cache successful responses for 30-45 seconds with automatic invalidation. Return cached data immediately if valid cache entry exists. Ensure cache TTL aligns with the 45-second auto-refresh interval configured in React Query."
        }
      ]
    },
    {
      "id": "REQ-57",
      "summary": "Implement graceful partial data rendering in CryptoTable component to display successful cryptocurrency data even when some requests fail, with row-level error indicators and retry buttons",
      "acceptanceCriteria": [
        "Successfully loaded cryptocurrencies display immediately even if some requests fail",
        "Failed coin rows show inline error indicators with retry buttons",
        "Users can see and interact with partial data while failures are isolated",
        "Overall UX remains functional with partial data"
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useCryptoPrices.ts",
          "operation": "modify",
          "description": "Modify the hook to return both successful and failed cryptocurrency data separately. Track failed requests with error information per coin. Allow partial success states where some coins load successfully while others fail. Provide retry function for individual failed coins."
        },
        {
          "path": "frontend/src/components/CryptoTable.tsx",
          "operation": "modify",
          "description": "Update table to render successfully loaded cryptocurrencies immediately even when some requests fail. Add inline error rows for failed coins with error indicators and individual retry buttons. Remove full error state that blocks display of partial data. Maintain existing trading signals and table sorting functionality for successful rows."
        }
      ]
    },
    {
      "id": "REQ-58",
      "summary": "Add enhanced retry logic for initial page load in Dashboard component with 4-5 retry attempts, longer backoff delays, and loading overlay showing retry progress",
      "acceptanceCriteria": [
        "Initial dashboard load uses 4-5 retry attempts instead of 3",
        "Retry delays are longer for initial load (2-5 seconds between attempts)",
        "Loading overlay shows current retry attempt number",
        "First load reliability is significantly improved"
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useCryptoPrices.ts",
          "operation": "modify",
          "description": "Implement enhanced retry configuration specifically for initial load detection. Increase retry attempts to 4-5 when isInitialLoading is true. Configure longer exponential backoff delays (2-5 seconds) for initial load. Track current retry attempt number and expose it for UI display. Preserve existing 3-retry configuration for subsequent refreshes."
        },
        {
          "path": "frontend/src/pages/Dashboard.tsx",
          "operation": "modify",
          "description": "Add loading overlay component that displays when initial data fetch is in progress and retries are occurring. Show current retry attempt number and progress indicator. Use isInitialLoading state from useCryptoPrices to control overlay visibility. Maintain existing 45-second auto-refresh and timeframe selector functionality."
        }
      ]
    },
    {
      "id": "REQ-59",
      "summary": "Improve chart data error handling in useChartData hook with exponential backoff retry and display user-friendly error message with retry button in CandlestickChart component",
      "acceptanceCriteria": [
        "useChartData hook implements exponential backoff retry logic",
        "CandlestickChart displays clear error message when data fails",
        "Retry button is prominently displayed in chart error state",
        "Automatic retry attempts before showing error to user"
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useChartData.ts",
          "operation": "modify",
          "description": "Add React Query retry configuration with exponential backoff (similar to useCryptoPrices implementation) for OHLC data fetching. Configure 3-4 retry attempts with increasing delays. Track error state and retry count. Provide manual retry function for user-triggered retries."
        },
        {
          "path": "frontend/src/components/CandlestickChart.tsx",
          "operation": "modify",
          "description": "Replace blank/empty chart state with user-friendly error message component when OHLC data fails to load. Display prominent retry button that triggers manual refetch. Show clear error explanation and maintain cyberpunk styling. Preserve existing chart rendering, technical indicators, and pattern detection when data loads successfully."
        }
      ]
    },
    {
      "id": "REQ-60",
      "summary": "Add global API health indicator in Layout component header showing CoinGecko availability status with colored badge and banner notification when issues are detected",
      "acceptanceCriteria": [
        "Status badge in header shows API health (green/yellow/red)",
        "Status is calculated from recent request success/failure rates",
        "Banner notification appears when API issues are widespread",
        "Users are informed proactively about data availability issues"
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useApiHealthMonitor.ts",
          "operation": "create",
          "description": "Create custom hook that monitors CoinGecko API health by tracking recent request success/failure rates from useCryptoPrices and useChartData hooks. Calculate health status (healthy/degraded/issues) based on success rate thresholds. Provide status color (green/yellow/red) and estimated recovery time when issues detected. Track rolling window of recent requests."
        },
        {
          "path": "frontend/src/components/Layout.tsx",
          "operation": "modify",
          "description": "Add API health status badge to header navigation area using useApiHealthMonitor hook. Display small colored indicator (green=healthy, yellow=degraded, red=issues) with tooltip. Add conditional banner notification below header when API issues are widespread, explaining data may be temporarily unavailable with estimated recovery time. Maintain existing navigation, theme toggle, and authentication button layout."
        }
      ]
    },
    {
      "id": "REQ-61",
      "summary": "Optimize React Query configuration in main.tsx to add smarter cache management with increased staleTime, cacheTime, and disabled window focus refetch",
      "acceptanceCriteria": [
        "React Query staleTime set to 30 seconds for crypto data",
        "React Query cacheTime set to 5 minutes",
        "Window focus refetch disabled for price queries",
        "Total API call volume reduced by 30-50%"
      ],
      "file_operations": [
        {
          "path": "frontend/src/main.tsx",
          "operation": "modify",
          "description": "Update QueryClient defaultOptions to set staleTime to 30 seconds and cacheTime to 5 minutes for all queries. Add refetchOnWindowFocus: false to prevent excessive API calls when users switch browser tabs. Maintain existing React Query setup, Internet Identity provider, and app rendering logic."
        },
        {
          "path": "frontend/src/hooks/useCryptoPrices.ts",
          "operation": "modify",
          "description": "Ensure useQuery configuration respects the global React Query defaults while maintaining the existing 45-second refetchInterval. Verify staleTime and cacheTime settings work correctly with auto-refresh behavior."
        }
      ]
    },
    {
      "id": "REQ-62",
      "summary": "Add request deduplication to coingecko.ts service to prevent multiple identical API calls from executing simultaneously using a promise cache",
      "acceptanceCriteria": [
        "Concurrent identical API requests share the same promise",
        "Only one actual HTTP request is made for duplicate concurrent calls",
        "Request deduplication works across different components",
        "No race conditions or stale data issues from deduplication"
      ],
      "file_operations": [
        {
          "path": "frontend/src/services/coingecko.ts",
          "operation": "modify",
          "description": "Implement in-flight request cache using Map to store promises by request URL. When identical concurrent requests occur, return the same promise instead of making multiple HTTP calls. Clear promise from cache when request completes (success or failure). Ensure request deduplication works alongside the response caching from REQ-56. Handle edge cases like request failures and cache cleanup."
        }
      ]
    }
  ]
}